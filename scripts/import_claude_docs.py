#!/usr/bin/env python3
"""
Import Claude-Generated Documentation

This script finds markdown files created by Claude CLI, processes them with 
the auto-tagging system, and imports them into the Document Management System.
It also maintains a record of imported files to avoid duplication.
"""

import os
import sys
import json
import re
import argparse
from pathlib import Path
from typing import List, Dict, Set, Any
import logging

# Add project root to path
PROJECT_ROOT = '/mnt/c/Users/angel/devloop'
if PROJECT_ROOT not in sys.path:
    sys.path.append(PROJECT_ROOT)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("doc_importer")

# Import knowledge API
try:
    from agents.utils.knowledge_api import knowledge_api
    KNOWLEDGE_API_AVAILABLE = True
except ImportError:
    logger.error("Knowledge API not available. Please check your installation.")
    KNOWLEDGE_API_AVAILABLE = False

# Constants
TRACKER_FILE = os.path.join(PROJECT_ROOT, 'knowledge_base', 'imported_docs.json')
CLAUDE_INDICATORS = [
    "# Claude ",
    "Generated by Claude",
    "Claude AI",
    "## Summary",
    "## Analysis",
    "## Implementation",
    "## Architecture",
    "ðŸ¤–",
    "claude",
    "anthropic"
]

def load_imported_docs() -> Dict[str, Any]:
    """Load the list of already imported documents"""
    if os.path.exists(TRACKER_FILE):
        try:
            with open(TRACKER_FILE, 'r') as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Error loading imported docs tracker: {e}")
            return {"imported_files": {}, "imported_count": 0, "last_import": None}
    else:
        return {"imported_files": {}, "imported_count": 0, "last_import": None}

def save_imported_docs(tracker: Dict[str, Any]) -> None:
    """Save the updated imported documents tracker"""
    try:
        # Ensure directory exists
        os.makedirs(os.path.dirname(TRACKER_FILE), exist_ok=True)
        
        # Update the last import timestamp
        import time
        tracker["last_import"] = time.time()
        
        # Save tracker
        with open(TRACKER_FILE, 'w') as f:
            json.dump(tracker, f, indent=2)
            
        logger.info(f"Updated import tracker. Total docs: {tracker['imported_count']}")
    except Exception as e:
        logger.error(f"Error saving imported docs tracker: {e}")

def is_claude_generated(file_path: str) -> bool:
    """Determine if a file was likely generated by Claude"""
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
            
        # Check for indicators
        for indicator in CLAUDE_INDICATORS:
            if indicator.lower() in content.lower():
                return True
                
        # Check for common Claude markdown patterns
        patterns = [
            r"## (Overview|Architecture|Implementation|Details|Analysis)",
            r"# [A-Z][a-z]+ (Guide|Documentation|Architecture|System|Implementation)",
            r"\*\*Claude\*\*",
            r"<claude>",
            r"\[Claude\]",
            r"Generated (with|by)"
        ]
        
        for pattern in patterns:
            if re.search(pattern, content):
                return True
                
        return False
    except Exception as e:
        logger.error(f"Error checking if file is Claude-generated: {e}")
        return False

def extract_title_from_md(file_path: str) -> str:
    """Extract the title from a markdown file"""
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            for line in f:
                line = line.strip()
                # Look for markdown heading level 1
                if line.startswith('# '):
                    return line[2:].strip()
        
        # If no heading found, use filename
        return os.path.basename(file_path).replace('.md', '').replace('_', ' ').title()
    except Exception as e:
        logger.error(f"Error extracting title: {e}")
        return os.path.basename(file_path)

def find_markdown_files(root_dir: str, exclusions: List[str] = None) -> List[str]:
    """Find all markdown files in the project"""
    if exclusions is None:
        exclusions = ['node_modules', 'venv', '.git']
        
    markdown_files = []
    
    for root, dirs, files in os.walk(root_dir):
        # Skip excluded directories
        dirs[:] = [d for d in dirs if d not in exclusions]
        
        for file in files:
            if file.lower().endswith('.md'):
                full_path = os.path.join(root, file)
                markdown_files.append(full_path)
                
    return markdown_files

def get_relative_path(file_path: str) -> str:
    """Get the path relative to the project root"""
    return os.path.relpath(file_path, PROJECT_ROOT)

def calculate_file_hash(file_path: str) -> str:
    """Calculate a hash of the file contents"""
    import hashlib
    
    try:
        with open(file_path, 'rb') as f:
            content = f.read()
            return hashlib.md5(content).hexdigest()
    except Exception as e:
        logger.error(f"Error calculating file hash: {e}")
        return ""

def import_markdown_to_knowledge_base(file_path: str, force: bool = False) -> Dict[str, Any]:
    """Import a markdown file to the knowledge base with auto-tagging"""
    if not KNOWLEDGE_API_AVAILABLE:
        return {'error': 'Knowledge API not available'}
        
    try:
        # Extract title for better organization
        title = extract_title_from_md(file_path)
        
        # Add to knowledge base with auto-tagging
        result = knowledge_api.add_document(
            file_path=file_path,
            tags=["claude-generated", "documentation"],
            auto_tag=True
        )
        
        if 'error' in result and 'already exists' in result['error'] and not force:
            logger.info(f"Document already exists in knowledge base: {file_path}")
            return {'status': 'exists', 'doc_id': result.get('doc_id')}
            
        logger.info(f"Imported document to knowledge base: {title}")
        return result
        
    except Exception as e:
        logger.error(f"Error importing markdown to knowledge base: {e}")
        return {'error': str(e)}

def main():
    """Main function"""
    parser = argparse.ArgumentParser(description="Import Claude-generated documentation to Knowledge Base")
    parser.add_argument("--dir", default=PROJECT_ROOT, help="Root directory to search for markdown files")
    parser.add_argument("--force", action="store_true", help="Force reimport of already imported files")
    parser.add_argument("--limit", type=int, default=0, help="Limit the number of files to import (0 for no limit)")
    parser.add_argument("--update-tracker", action="store_true", help="Just update the tracker without importing")
    parser.add_argument("--claude-only", action="store_true", help="Only import files likely generated by Claude")
    
    args = parser.parse_args()
    
    if not KNOWLEDGE_API_AVAILABLE:
        logger.error("Knowledge API not available. Please check your installation.")
        return
    
    # Load tracker of imported documents
    tracker = load_imported_docs()
    imported_files = tracker["imported_files"]
    
    # Find all markdown files
    markdown_files = find_markdown_files(args.dir)
    logger.info(f"Found {len(markdown_files)} markdown files")
    
    # Filter to only include Claude-generated files if requested
    if args.claude_only:
        claude_files = []
        for file_path in markdown_files:
            if is_claude_generated(file_path):
                claude_files.append(file_path)
        logger.info(f"Filtered to {len(claude_files)} Claude-generated files")
        markdown_files = claude_files
    
    # Just update tracker if requested
    if args.update_tracker:
        for file_path in markdown_files:
            rel_path = get_relative_path(file_path)
            file_hash = calculate_file_hash(file_path)
            
            if rel_path not in imported_files:
                imported_files[rel_path] = {
                    "file_hash": file_hash,
                    "imported": False,
                    "title": extract_title_from_md(file_path)
                }
        
        tracker["imported_count"] = sum(1 for info in imported_files.values() if info["imported"])
        save_imported_docs(tracker)
        logger.info(f"Updated tracker with {len(imported_files)} files")
        return
    
    # Import files
    import_count = 0
    limit = args.limit if args.limit > 0 else len(markdown_files)
    
    for file_path in markdown_files:
        if import_count >= limit:
            break
            
        rel_path = get_relative_path(file_path)
        file_hash = calculate_file_hash(file_path)
        
        # Skip if already imported and not forcing reimport
        if rel_path in imported_files and imported_files[rel_path]["imported"] and imported_files[rel_path]["file_hash"] == file_hash and not args.force:
            logger.info(f"Skipping already imported file: {rel_path}")
            continue
        
        # Import file to knowledge base
        result = import_markdown_to_knowledge_base(file_path, args.force)
        
        # Update tracker
        if 'error' not in result or ('status' in result and result['status'] == 'exists'):
            if rel_path not in imported_files:
                imported_files[rel_path] = {}
                
            imported_files[rel_path]["file_hash"] = file_hash
            imported_files[rel_path]["imported"] = True
            imported_files[rel_path]["doc_id"] = result.get('doc_id', '')
            imported_files[rel_path]["title"] = extract_title_from_md(file_path)
            imported_files[rel_path]["last_imported"] = import_count
            
            import_count += 1
            
            # Print progress
            print(f"[{import_count}/{limit}] Imported: {rel_path}")
    
    # Update tracker
    tracker["imported_count"] = sum(1 for info in imported_files.values() if info["imported"])
    save_imported_docs(tracker)
    
    logger.info(f"Import complete. Imported {import_count} files.")
    print(f"\nImport complete. Imported {import_count} files to Knowledge Base.")
    print(f"Total documents in tracker: {len(imported_files)}")
    print(f"Total imported documents: {tracker['imported_count']}")

if __name__ == "__main__":
    main()